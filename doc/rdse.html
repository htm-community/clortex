<html><head><meta content="chrome=1" http-equiv="X-UA-Compatible" /><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport" /><title>Random Distributed Scalar Encoder</title><style>body {
  padding:50px;
  font:14px/1.5 Helvetica, Arial, sans-serif;
  color:#777;
  font-weight:300;
}

h1, h2, h3, h4, h5, h6 {
  color:#222;
  margin:0 0 20px;
}

p, ul, ol, table, pre, dl {
  margin:0 0 20px;
}

h1, h2, h3 {
  line-height:1.1;
}

h1 {
  font-size:28px;
}

h2 {
  color:#393939;
}

h4, h5, h6 {
  color:#494949;
  margin:0;
}

header h4{
  margin: 10 0 0 0px;
}

a {
  color:#39c;
  font-weight:400;
  text-decoration:none;
}

a small {
  font-size:11px;
  color:#777;
  margin-top:-0.6em;
  display:block;
}

.wrapper {
  width:860px;
  margin:0 auto;
}

.figure div.img {
  text-align: center;
  border-radius: 5px;
  border: 1px solid #ddd;
  padding: 10px;
}

blockquote {
  border-left:1px solid #e5e5e5;
  margin:0;
  padding:0 0 0 20px;
  font-style:italic;
}

code, pre {
  font-family:Monaco, Bitstream Vera Sans Mono, Lucida Console, Terminal;
  color:#333;
  font-size:12px;
}

pre {
  padding:8px 15px;
  background: #f8f8f8;  
  border-radius:5px;
  border:1px solid #e5e5e5;
  overflow-x: auto;
}

table {
  width:100%;
  border-collapse:collapse;
}

th, td {
  text-align:left;
  padding:5px 10px;
  border-bottom:1px solid #e5e5e5;
}

dt {
  color:#444;
  font-weight:700;
}

th {
  color:#444;
}

img {
  max-width:100%;
}

header {
  width:270px;
  float:left;
  /*position:fixed;*/
}

header ul {
  list-style:none;
  height:40px;
  
  padding:0;
  
  background: #eee;
  background: -moz-linear-gradient(top, #f8f8f8 0%, #dddddd 100%);
  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f8f8f8), color-stop(100%,#dddddd));
  background: -webkit-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: -o-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: -ms-linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  background: linear-gradient(top, #f8f8f8 0%,#dddddd 100%);
  
  border-radius:5px;
  border:1px solid #d2d2d2;
  box-shadow:inset #fff 0 1px 0, inset rgba(0,0,0,0.03) 0 -1px 0;
  width:270px;
}

header li {
  width:89px;
  float:left;
  border-right:1px solid #d2d2d2;
  height:40px;
}

header ul a {
  line-height:1;
  font-size:11px;
  color:#999;
  display:block;
  text-align:center;
  padding-top:6px;
  height:40px;
}

strong {
  font-weight:700;
}

header ul li + li {
  width:88px;
  border-left:1px solid #fff;
}

header ul li + li + li {
  border-right:none;
  width:89px;
}

header ul a strong {
  font-size:14px;
  display:block;
  color:#222;
}

section {
  width: 60%;
  float:right;
  padding-bottom:50px;
  padding-right: 10%;
}

small {
  font-size:11px;
}

hr {
  border:0;
  background:#e5e5e5;
  height:1px;
  margin:0 0 20px;
}

footer {
  width:270px;
  float:left;
  position:fixed;
  bottom:50px;
}

header div.heading {
  display:none;
}


@media print, screen and (max-width: 960px) {
  
  div.wrapper {
    width:auto;
    margin:0;
  }
  
  header, section, footer {
    float:none;
    position:static;
    width:auto;
  }
  
  header div.heading {
    display:block;
  }
    
  section div.heading {
    display:none;
  }
  
  section {
    border:1px solid #e5e5e5;
    border-width:1px 0;
    padding:20px 0;
    margin:0 0 20px;
  }
  
  header a small {
    display:inline;
  }
  
  header ul {
    position:absolute;
    right:50px;
    top:52px;
  }
}

@media print, screen and (max-width: 720px) {
  body {
    word-wrap:break-word;
  }
  
  header {
    padding:0;
  }
  
  header ul, header p.view {
    position:static;
  }
  
  pre, code {
    word-wrap:normal;
  }
}

@media print, screen and (max-width: 480px) {
  body {
    padding:15px;
  }
  
  header ul {
    display:none;
  }
}

@media print {
  body {
    padding:0.4in;
    font-size:12pt;
    color:#444;
  }
}


.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold; } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kn { font-weight: bold } /* Keyword.Namespace */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */

.type-csharp .highlight .k { color: #0000FF }
.type-csharp .highlight .kt { color: #0000FF }
.type-csharp .highlight .nf { color: #000000; font-weight: normal }
.type-csharp .highlight .nc { color: #2B91AF }
.type-csharp .highlight .nn { color: #000000 }
.type-csharp .highlight .s { color: #A31515 }
.type-csharp .highlight .sc { color: #A31515 }


</style></head><body><header><div class="heading"><h1>Random Distributed Scalar Encoder</h1><h3>Experiments on improving the Scalar Encoder</h3><hr /><div class="info"><h5>Author: Fergal Byrne<b>&nbsp;&nbsp;<a href="mailto:fergalbyrnedublin@gmail.com">(fergalbyrnedublin@gmail.com)</a></b></h5><h5>Library: v0.1.1-SNAPSHOT</h5><h5>Date: 20 July 2014</h5><h5>Website: <a href="https://github.com/fergalbyrne/clortex">https://github.com/fergalbyrne/clortex</a></h5><h5>Generated By: <a href="http://www.github.com/zcaudate/lein-midje-doc">MidjeDoc</a></h5></div><br /><hr /></div><h4><a href="#background">1 &nbsp; Background</a></h4><h5>&nbsp;&nbsp;<i><a href="#the-current-scalar-encoder">1.1 &nbsp; The Current Scalar Encoder</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#the-random-distributed-scalar-encoder">1.2 &nbsp; The Random Distributed Scalar Encoder</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#basic-random-distributed-scalar-encoder---implementation">1.2.1 &nbsp; Basic Random Distributed Scalar Encoder - Implementation</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#testing-the-rdse-on-4-of-12-bit-encoding">1.2.2 &nbsp; Testing the RDSE on 4-of-12-bit encoding</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#a-larger-encoding:-21-of-128-bits">1.2.3 &nbsp; A larger encoding: 21-of-128 bits</a></i></h5><h5>&nbsp;&nbsp;&nbsp;&nbsp;<i><a href="#encoding-is-dependent-on-order-of-data">1.2.4 &nbsp; Encoding is dependent on order of data</a></i></h5><h5>&nbsp;&nbsp;<i><a href="#conclusions-and-further-improvements">1.3 &nbsp; Conclusions and Further Improvements</a></i></h5><br /></header><section><div class="heading"><h1>Random Distributed Scalar Encoder</h1><h3>Experiments on improving the Scalar Encoder</h3><hr /><div class="info"><h5>Author: Fergal Byrne<b>&nbsp;&nbsp;<a href="mailto:fergalbyrnedublin@gmail.com">(fergalbyrnedublin@gmail.com)</a></b></h5><h5>Library: v0.1.1-SNAPSHOT</h5><h5>Date: 20 July 2014</h5><h5>Website: <a href="https://github.com/fergalbyrne/clortex">https://github.com/fergalbyrne/clortex</a></h5><h5>Generated By: <a href="http://www.github.com/zcaudate/lein-midje-doc">MidjeDoc</a></h5></div><br /><hr /></div><div><a name="background"></a><h2><b>1 &nbsp;&nbsp; Background</b></h2></div><div><p>Chetan Surpur gave a great talk on a new version of the Scalar Encoder for NuPIC (<a href='http://www.youtube.com/watch?v=&#95;q5W2Ov6C9E'>video</a>). This document explores the implications of the new design and makes some recommendations about further improvements.</p><p>A <strong>Scalar Encoder</strong> is a function which converts a scalar value <code>v</code> into a bit map <code>sdr</code> with a given number <code>bits</code> of possible bits, of which <code>width</code> bits are 1 and the rest are 0. One important property of the SDRs is that values close together share many more bits than values further apart.</p><p>Here's a simple example:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">enc</span> <span class="p">(</span><span class="nf">s/scalar-encoder</span> <span class="ss">:bits</span> <span class="mi">12</span> <span class="ss">:on</span> <span class="mi">4</span> <span class="ss">:minimum</span> <span class="mi">1</span> <span class="ss">:maximum</span> <span class="mi">12</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring</span> <span class="nv">enc</span><span class="p">))</span>

<span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">13</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="p">[</span><span class="s">&quot;111100000000&quot;</span>
    <span class="s">&quot;011110000000&quot;</span>
    <span class="s">&quot;001111000000&quot;</span>
    <span class="s">&quot;000111100000&quot;</span>
    <span class="s">&quot;000111100000&quot;</span>
    <span class="s">&quot;000011110000&quot;</span>
    <span class="s">&quot;000001111000&quot;</span>
    <span class="s">&quot;000000111100&quot;</span>
    <span class="s">&quot;000000111100&quot;</span>
    <span class="s">&quot;000000011110&quot;</span>
    <span class="s">&quot;000000001111&quot;</span>
    <span class="s">&quot;000000001111&quot;</span><span class="p">]</span>
</pre></div>
</div><div><a name="the-current-scalar-encoder"></a><h3>1.1 &nbsp;&nbsp; The Current Scalar Encoder</h3></div><div><p>The current scalar encoder (see example above) represents each scalar using a sliding window of <code>on</code> 1's. The current scalar encoder has the benefit of being instantly understandable (once you see an example like the one in the first section) and visually decodable by the user. It does, however, have a number of limitations.</p><p>The encoder is given a <code>min</code> and <code>max</code> when defined and it clamps its output when given values outside its initial range.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">-20</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;111100000000&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">20</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;000000001111&quot;</span>
</pre></div>
</div><div><p>This means that the above two values come to represent many values, and the region receiving the encoding will not be able to discriminate between these values.</p><p>The second limitation is that the encoding is very inefficient in its use of available bits. The number of possible <code>on</code>-bits out of <code>bits</code> bits is given by the <code>binomial</code> coefficient:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">binomial</span> <span class="mi">12</span> <span class="mi">4</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">495</span>
</pre></div>
</div><div><p>which is significantly larger than the number of distinct SDRs produced by the <code>scalar-encoder</code>:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="mi">-100</span> <span class="mi">100</span><span class="p">))))</span> <span class="nv">=&gt;</span> <span class="mi">9</span>
</pre></div>
</div><div><p>This encoder is only using 1.8% of the SDRs available. Perhaps this is an extreme example because of the very small number of bits. Let's check the numbers for a more typical encoder:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">enc</span> <span class="p">(</span><span class="nf">s/scalar-encoder</span> <span class="ss">:bits</span> <span class="mi">512</span> <span class="ss">:on</span> <span class="mi">21</span> <span class="ss">:minimum</span> <span class="mi">1</span> <span class="ss">:maximum</span> <span class="mi">512</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring</span> <span class="nv">enc</span><span class="p">))</span>
<span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">binomial</span> <span class="mi">512</span> <span class="mi">21</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="s">&quot;10133758886507113849867996785041062400&quot;</span>
<span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="mi">-100</span> <span class="mi">1000</span><span class="p">))))</span> <span class="nv">=&gt;</span> <span class="mi">492</span>
</pre></div>
</div><div><p>Oh dear.</p></div><div><a name="the-random-distributed-scalar-encoder"></a><h3>1.2 &nbsp;&nbsp; The Random Distributed Scalar Encoder</h3></div><div><p>Chetan's talk explains a new approach. The idea is to use a set of 'buckets' to represent a set of intervals in the encoders range, and to encode each one using a randomly chosen set of <code>on</code> bits. The property of semantic closeness is achieved by only changing one bit at a time when choosing the bits for the next bucket along.</p><p>Let's implement an RDSE. We'll need a utility function so we always get the same SDRs.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">randomer</span> <span class="p">(</span><span class="nf">random-fn-with-seed</span> <span class="mi">123456</span><span class="p">))</span> <span class="c1">; returns the same sequence of random numbers</span>
<span class="p">(</span><span class="nf">randomer</span> <span class="mi">10</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">3</span>
<span class="p">(</span><span class="nf">randomer</span> <span class="mi">10</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="mi">7</span>
</pre></div>
</div><div><a name="basic-random-distributed-scalar-encoder---implementation"></a><h3><i>1.2.1 &nbsp;&nbsp; Basic Random Distributed Scalar Encoder - Implementation</i></h3></div><div><p>The following is a basic RDSE implemented in Clojure. It starts off empty, and adds buckets lazily as new values are encoded. <strong>Please let me know if there is anything unclear in this code!</strong>.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">bottom-sorter</span>
    <span class="s">&quot;sorts buckets by their bottom value&quot;</span>
    <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">compare</span> <span class="p">(</span><span class="nf">x</span> <span class="ss">:bottom</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span> <span class="ss">:bottom</span><span class="p">))]</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">c</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">compare</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
             <span class="nv">c</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">ordered-bins</span> <span class="p">[</span><span class="nv">bins</span><span class="p">]</span> <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:bottom</span> <span class="nv">bins</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">find-bucket</span>
    <span class="s">&quot;returns the bucket which covers value. updates the &#39;read&#39; slot of the bucket&quot;</span>
    <span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">value</span> <span class="nv">buckets</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">bucket</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="ss">:bottom</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">value</span> <span class="p">(</span><span class="ss">:top</span> <span class="nv">%</span><span class="p">))</span> <span class="p">(</span><span class="ss">:bins</span> <span class="nv">buckets</span><span class="p">)))]</span>
        <span class="nv">bucket</span><span class="p">))</span><span class="c1">; removed from find-bucket to make it pure; (swap! buckets update-in [:bins (:index bucket) :read] inc)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">new-bucket</span>
    <span class="s">&quot;returns a bucket map given centre, radius and index&quot;</span>
    <span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">value</span> <span class="o">^</span><span class="nb">double </span><span class="nv">radius</span> <span class="o">^</span><span class="nb">long </span><span class="nv">index</span><span class="p">]</span>
    <span class="p">{</span><span class="ss">:bottom</span> <span class="p">(</span><span class="nb">- </span><span class="nv">value</span> <span class="nv">radius</span><span class="p">)</span> <span class="ss">:top</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">value</span> <span class="nv">radius</span><span class="p">)</span> <span class="ss">:index</span> <span class="nb">index </span><span class="ss">:counter</span> <span class="mi">1</span> <span class="ss">:read</span> <span class="mi">0</span><span class="p">})</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">min-distance</span>
    <span class="s">&quot;used to accumulate the best nearby bucket when searching&quot;</span>
    <span class="p">[</span><span class="nv">acc</span> <span class="nv">a-bucket</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">diff</span> <span class="p">(</span><span class="nb">min </span><span class="p">(</span><span class="nf">abs-diff</span> <span class="p">(</span><span class="ss">:mine</span> <span class="nv">acc</span><span class="p">)</span> <span class="p">(</span><span class="ss">:bottom</span> <span class="nv">a-bucket</span><span class="p">))</span>
                    <span class="p">(</span><span class="ss">:best</span> <span class="nv">acc</span><span class="p">))]</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">diff</span> <span class="p">(</span><span class="ss">:best</span> <span class="nv">acc</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">conj </span><span class="nv">acc</span> <span class="p">{</span><span class="ss">:index</span> <span class="p">(</span><span class="ss">:index</span> <span class="nv">a-bucket</span><span class="p">)</span> <span class="ss">:best</span> <span class="nv">diff</span><span class="p">})</span>
             <span class="nv">acc</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">sdrs</span> <span class="p">[</span><span class="nv">bins</span><span class="p">]</span> <span class="p">(</span><span class="nb">reduce conj </span><span class="o">#</span><span class="p">{}</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:sdr</span> <span class="nv">bins</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">bottom-of-buckets</span> <span class="p">[</span><span class="nv">bins</span><span class="p">]</span> <span class="p">(</span><span class="nb">reduce min </span><span class="p">(</span><span class="nb">map </span><span class="ss">:bottom</span> <span class="nv">bins</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">top-of-buckets</span> <span class="p">[</span><span class="nv">bins</span><span class="p">]</span> <span class="p">(</span><span class="nb">reduce max </span><span class="p">(</span><span class="nb">map </span><span class="ss">:top</span> <span class="nv">bins</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">n-bins</span> <span class="p">[</span><span class="nv">buckets</span><span class="p">]</span> <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="ss">:bins</span> <span class="nv">buckets</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">search-starter</span> <span class="p">[</span><span class="nv">bucket</span><span class="p">]</span> <span class="p">{</span><span class="ss">:index</span> <span class="nv">nil</span> <span class="ss">:best</span> <span class="nv">Integer/MAX_VALUE</span>  <span class="ss">:mine</span> <span class="p">(</span><span class="ss">:bottom</span> <span class="nv">bucket</span><span class="p">)})</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">sdr-&gt;bitstring</span> <span class="p">[</span><span class="nv">sdr</span> <span class="nv">bits</span><span class="p">]</span> <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">contains? </span><span class="p">(</span><span class="nb">set </span><span class="nv">sdr</span><span class="p">)</span> <span class="nv">%</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="nv">bits</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">new-sdr</span>
    <span class="p">[</span><span class="nv">bucket</span> <span class="nv">buckets</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">bins</span> <span class="p">(</span><span class="ss">:bins</span> <span class="nv">buckets</span><span class="p">)</span>
          <span class="o">^</span><span class="nb">int </span><span class="nv">on</span> <span class="p">(</span><span class="ss">:on</span> <span class="nv">buckets</span><span class="p">)</span>
          <span class="o">^</span><span class="nb">int </span><span class="nv">bits</span> <span class="p">(</span><span class="ss">:bits</span> <span class="nv">buckets</span><span class="p">)</span>
          <span class="nv">randomer</span> <span class="p">(</span><span class="ss">:randomer</span> <span class="nv">buckets</span><span class="p">)]</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">bins</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">range </span><span class="nv">on</span><span class="p">))</span>
             <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">sorted-bins</span> <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:bottom</span> <span class="nv">bins</span><span class="p">)</span>
                   <span class="nv">above?</span> <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="ss">:bottom</span> <span class="nv">bucket</span><span class="p">)</span> <span class="p">(</span><span class="ss">:bottom</span> <span class="p">(</span><span class="nb">first </span><span class="nv">sorted-bins</span><span class="p">)))</span>
                   <span class="nv">nearest-buckets</span>
                       <span class="p">(</span><span class="k">if </span><span class="nv">above?</span>
                           <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">drop </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">count </span><span class="nv">sorted-bins</span><span class="p">)</span> <span class="nv">on</span><span class="p">)</span> <span class="nv">sorted-bins</span><span class="p">)))</span>
                           <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">take </span><span class="nv">on</span> <span class="nv">sorted-bins</span><span class="p">)))</span>
                   <span class="nv">nearest-bits</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">union </span><span class="nv">%1</span> <span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="ss">:sdr</span> <span class="nv">%2</span><span class="p">)))</span> <span class="o">#</span><span class="p">{}</span> <span class="nv">nearest-buckets</span><span class="p">)))</span>
                   <span class="nv">previous-sdr</span> <span class="p">(</span><span class="ss">:sdr</span> <span class="p">(</span><span class="nb">first </span><span class="nv">nearest-buckets</span><span class="p">))</span>
                   <span class="nv">previous-sdr</span> <span class="p">(</span><span class="k">if </span><span class="nv">above?</span> <span class="nv">previous-sdr</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">previous-sdr</span><span class="p">)))</span>
                   <span class="nv">remove-bit</span> <span class="p">(</span><span class="nf">previous-sdr</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">randomer</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">on</span><span class="p">))))</span>
                   <span class="nv">remove-bit</span> <span class="p">(</span><span class="nf">previous-sdr</span> <span class="p">(</span><span class="nf">randomer</span> <span class="nv">on</span><span class="p">))</span>
                   <span class="nv">same-bits</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">disj </span><span class="p">(</span><span class="nb">set </span><span class="nv">previous-sdr</span><span class="p">)</span> <span class="nv">remove-bit</span><span class="p">))</span>
                   <span class="nv">free-bits</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">difference </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">range </span><span class="nv">bits</span><span class="p">))</span> <span class="p">(</span><span class="nb">set </span><span class="nv">nearest-bits</span><span class="p">)))</span>
                   <span class="nv">new-bit-pos</span> <span class="p">(</span><span class="nf">randomer</span> <span class="p">(</span><span class="nb">count </span><span class="nv">free-bits</span><span class="p">))</span>
                   <span class="nv">new-bit</span> <span class="p">(</span><span class="nf">free-bits</span> <span class="nv">new-bit-pos</span><span class="p">)</span>
                   <span class="nv">new-sdr</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">set </span><span class="nv">same-bits</span><span class="p">)</span> <span class="nv">new-bit</span><span class="p">)))]</span>
                <span class="nv">new-sdr</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">add-to-buckets!</span>
    <span class="p">[</span><span class="nv">buckets</span> <span class="nv">bucket</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">bits</span> <span class="p">(</span><span class="ss">:bits</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">)</span>
         <span class="nv">sdr</span> <span class="p">(</span><span class="nf">new-sdr</span> <span class="nv">bucket</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">)</span>
         <span class="nv">sdr-bucket</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">bucket</span> <span class="p">{</span><span class="ss">:sdr</span> <span class="nv">sdr</span><span class="p">})</span>
         <span class="c1">;bitstring (sdr-&gt;bitstring sdr bits)</span>
         <span class="c1">;sdr-bucket (conj bucket {:sdr sdr :bitstring bitstring})</span>
         <span class="p">]</span>
       <span class="p">(</span><span class="nf">swap!</span> <span class="nv">buckets</span> <span class="nv">update-in</span> <span class="p">[</span><span class="ss">:bins</span><span class="p">]</span> <span class="nb">conj </span><span class="nv">sdr-bucket</span><span class="p">)</span>
       <span class="nv">sdr-bucket</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">add-bucket!</span>
    <span class="p">[</span><span class="nv">value</span> <span class="nv">buckets</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">diameter</span> <span class="p">(</span><span class="ss">:diameter</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">)</span>
          <span class="nv">radius</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">diameter</span> <span class="mf">2.0</span><span class="p">)</span>
          <span class="nv">mn</span> <span class="o">#</span><span class="p">(</span><span class="nf">bottom-of-buckets</span> <span class="p">(</span><span class="ss">:bins</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))</span>
	      <span class="nv">mx</span> <span class="o">#</span><span class="p">(</span><span class="nf">top-of-buckets</span> <span class="p">(</span><span class="ss">:bins</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="p">(</span><span class="ss">:bins</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))</span>
        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">bucket</span> <span class="p">(</span><span class="nf">new-bucket</span> <span class="nv">value</span> <span class="nv">radius</span> <span class="p">(</span><span class="nf">n-bins</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))]</span>
          <span class="p">(</span><span class="nf">add-to-buckets!</span> <span class="nv">buckets</span> <span class="nv">bucket</span><span class="p">))</span>
        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">value</span> <span class="p">(</span><span class="nf">mx</span><span class="p">))</span>
	           <span class="p">(</span><span class="nf">add-to-buckets!</span> <span class="nv">buckets</span> <span class="p">(</span><span class="nf">new-bucket</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">mx</span><span class="p">)</span> <span class="nv">radius</span><span class="p">)</span> <span class="nv">radius</span> <span class="p">(</span><span class="nf">n-bins</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))))</span>
	        <span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">&lt; </span><span class="nv">value</span> <span class="p">(</span><span class="nf">mn</span><span class="p">))</span>
	           <span class="p">(</span><span class="nf">add-to-buckets!</span> <span class="nv">buckets</span> <span class="p">(</span><span class="nf">new-bucket</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">mn</span><span class="p">)</span> <span class="nv">radius</span><span class="p">)</span> <span class="nv">radius</span> <span class="p">(</span><span class="nf">n-bins</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))))))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">random-sdr-encoder-1</span>
    <span class="p">[</span><span class="o">&amp;</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">diameter</span> <span class="o">^</span><span class="nb">int </span><span class="nv">bits</span> <span class="o">^</span><span class="nb">int </span><span class="nv">on</span><span class="p">]</span> <span class="ss">:or</span> <span class="p">{</span><span class="nv">diameter</span> <span class="mf">1.0</span> <span class="nv">bits</span> <span class="mi">127</span> <span class="nv">on</span> <span class="mi">21</span><span class="p">}}]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">randomer</span>
            <span class="p">(</span><span class="nf">random-fn-with-seed</span> <span class="mi">123456</span><span class="p">)</span>
          <span class="nv">buckets</span>
            <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:diameter</span> <span class="nv">diameter</span> <span class="ss">:bits</span> <span class="nv">bits</span> <span class="ss">:on</span> <span class="nv">on</span> <span class="ss">:randomer</span> <span class="nv">randomer</span> <span class="ss">:bins</span> <span class="p">[]})</span>
          <span class="nv">encode!</span>
            <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">x</span><span class="p">]</span>
                <span class="p">(</span><span class="nb">if-not </span><span class="p">(</span><span class="nf">find-bucket</span> <span class="nv">x</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">)</span> <span class="p">(</span><span class="nf">add-bucket!</span> <span class="nv">x</span> <span class="nv">buckets</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="ss">:sdr</span> <span class="p">(</span><span class="nf">find-bucket</span> <span class="nv">x</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))))</span>
          <span class="nv">encode-to-bitstring!</span>
            <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">x</span><span class="p">]</span>
                <span class="p">(</span><span class="nf">sdr-&gt;bitstring</span> <span class="p">(</span><span class="nf">encode!</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">bits</span><span class="p">))]</span>
        <span class="p">{</span><span class="ss">:buckets</span> <span class="nv">buckets</span>
         <span class="ss">:encode</span> <span class="nv">encode!</span>
         <span class="ss">:encode-to-bitstring!</span> <span class="nv">encode-to-bitstring!</span>
         <span class="ss">:bits</span> <span class="nv">bits</span>
         <span class="ss">:on</span> <span class="nv">on</span><span class="p">}))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">precalculate</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">f</span> <span class="o">&amp;</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">center</span> <span class="nv">step</span><span class="p">]</span> <span class="ss">:or</span> <span class="p">{</span><span class="nv">center</span> <span class="mf">0.0</span> <span class="nv">step</span> <span class="mf">10.0</span><span class="p">}}]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">bands</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">step</span><span class="p">)))]</span>
       <span class="p">(</span><span class="nb">dorun </span><span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">band</span> <span class="p">(</span><span class="nb">map inc </span><span class="p">(</span><span class="nb">range </span><span class="nv">bands</span><span class="p">))]</span>
           <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">center</span> <span class="p">(</span><span class="nb">* </span><span class="nv">step</span> <span class="nv">band</span><span class="p">)))</span>
               <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">center</span> <span class="p">(</span><span class="nb">* </span><span class="nv">step</span> <span class="nv">band</span><span class="p">)))</span>
<span class="c1">;(println (str &quot;precalculating [&quot; (- 0 (* step band)) &quot;,&quot; (* step band) &quot;]&quot;))</span>
           <span class="p">))))</span>
    <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">random-sdr-encoder</span>
    <span class="p">[</span><span class="o">&amp;</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">diameter</span> <span class="o">^</span><span class="nb">int </span><span class="nv">bits</span> <span class="o">^</span><span class="nb">int </span><span class="nv">on</span> <span class="o">^</span><span class="nb">double </span><span class="nv">center</span><span class="p">]</span>
        <span class="ss">:or</span> <span class="p">{</span><span class="nv">diameter</span> <span class="mf">1.0</span> <span class="nv">bits</span> <span class="mi">127</span> <span class="nv">on</span> <span class="mi">21</span> <span class="nv">center</span> <span class="mf">0.0</span><span class="p">}}]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">randomer</span>
            <span class="p">(</span><span class="nf">random-fn-with-seed</span> <span class="mi">123456</span><span class="p">)</span>
          <span class="nv">buckets</span>
            <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:diameter</span> <span class="nv">diameter</span> <span class="ss">:bits</span> <span class="nv">bits</span> <span class="ss">:on</span> <span class="nv">on</span> <span class="ss">:randomer</span> <span class="nv">randomer</span> <span class="ss">:bins</span> <span class="p">[]})</span>
          <span class="nv">encode!</span>
            <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">x</span><span class="p">]</span>
                <span class="p">(</span><span class="nb">if-not </span><span class="p">(</span><span class="nf">find-bucket</span> <span class="nv">x</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">)</span> <span class="p">(</span><span class="nf">add-bucket!</span> <span class="nv">x</span> <span class="nv">buckets</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="ss">:sdr</span> <span class="p">(</span><span class="nf">find-bucket</span> <span class="nv">x</span> <span class="o">@</span><span class="nv">buckets</span><span class="p">))))</span>
          <span class="nv">encode</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">precalculate</span> <span class="nv">x</span> <span class="nv">encode!</span> <span class="ss">:center</span> <span class="nv">center</span> <span class="ss">:step</span> <span class="p">(</span><span class="nb">* </span><span class="mi">10</span> <span class="nv">diameter</span><span class="p">)))</span>
          <span class="nv">encode-to-bitstring!</span>
            <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">x</span><span class="p">]</span>
                <span class="p">(</span><span class="nf">sdr-&gt;bitstring</span> <span class="p">(</span><span class="nf">encode!</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">bits</span><span class="p">))]</span>
        <span class="p">{</span><span class="ss">:buckets</span> <span class="nv">buckets</span>
         <span class="ss">:encode</span> <span class="nv">encode</span>
         <span class="ss">:encode-to-bitstring!</span> <span class="nv">encode-to-bitstring!</span>
         <span class="ss">:bits</span> <span class="nv">bits</span>
         <span class="ss">:on</span> <span class="nv">on</span><span class="p">}))</span>
</pre></div>
</div><div><a name="testing-the-rdse-on-4-of-12-bit-encoding"></a><h3><i>1.2.2 &nbsp;&nbsp; Testing the RDSE on 4-of-12-bit encoding</i></h3></div><div><p>Let's re-run the tests for the simple 12 bit encoder, where we had very quickly saturated the basic <code>scalar-encoder</code>.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">encoder</span> <span class="p">(</span><span class="nf">r/random-sdr-encoder-1</span> <span class="ss">:diameter</span> <span class="mf">1.0</span> <span class="ss">:bits</span> <span class="mi">12</span> <span class="ss">:on</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">buckets</span> <span class="p">(</span><span class="ss">:buckets</span> <span class="nv">encoder</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring!</span> <span class="nv">encoder</span><span class="p">))</span>

<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;111100000000&quot;</span>

<span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="mi">-5</span> <span class="mi">22</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">[</span><span class="s">&quot;000010111000&quot;</span>
     <span class="s">&quot;010010101000&quot;</span>
     <span class="s">&quot;010010001001&quot;</span>
     <span class="s">&quot;011010000001&quot;</span>
     <span class="s">&quot;011001000001&quot;</span>
     <span class="s">&quot;011100000001&quot;</span>
     <span class="s">&quot;111100000000&quot;</span>
     <span class="s">&quot;111000001000&quot;</span>
     <span class="s">&quot;011000001010&quot;</span>
     <span class="s">&quot;011000101000&quot;</span>
     <span class="s">&quot;010000101100&quot;</span>
     <span class="s">&quot;000100101100&quot;</span>
     <span class="s">&quot;000101101000&quot;</span>
     <span class="s">&quot;000101001010&quot;</span>
     <span class="s">&quot;000101010010&quot;</span>
     <span class="s">&quot;010001010010&quot;</span>
     <span class="s">&quot;001001010010&quot;</span>
     <span class="s">&quot;000001110010&quot;</span>
     <span class="s">&quot;000000110110&quot;</span>
     <span class="s">&quot;100000110100&quot;</span>
     <span class="s">&quot;000000111100&quot;</span>
     <span class="s">&quot;010000111000&quot;</span>
     <span class="s">&quot;001000111000&quot;</span>
     <span class="s">&quot;001000011001&quot;</span>
     <span class="s">&quot;101000010001&quot;</span>
     <span class="s">&quot;100000010011&quot;</span>
     <span class="s">&quot;100000010101&quot;</span><span class="p">]</span>

<span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="mi">-500</span> <span class="mi">500</span><span class="p">))))</span> <span class="nv">=&gt;</span> <span class="mi">436</span>
</pre></div>
</div><div><p>As we can see, this encoder is capable of storing 436 out of 495 passible encodings (note that each pair of encoded buckets differs only in one bit, so this is pretty good).</p></div><div><a name="a-larger-encoding:-21-of-128-bits"></a><h3><i>1.2.3 &nbsp;&nbsp; A larger encoding: 21-of-128 bits</i></h3></div><div><p>Let's see how much capacity we can get with a more typical 128 bit encoding (standard 21 bits on).</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">encoder</span> <span class="p">(</span><span class="nf">r/random-sdr-encoder-1</span> <span class="ss">:diameter</span> <span class="mf">1.0</span> <span class="ss">:bits</span> <span class="mi">128</span> <span class="ss">:on</span> <span class="mi">21</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">buckets</span> <span class="p">(</span><span class="ss">:buckets</span> <span class="nv">encoder</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring!</span> <span class="nv">encoder</span><span class="p">))</span>
<span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">binomial</span> <span class="mi">512</span> <span class="mi">21</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="s">&quot;10133758886507113849867996785041062400&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;11111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;11111111111111111111000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>
</pre></div>
</div><div><p>We'll put 10000 values into the encoder.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">n</span> <span class="mi">10000</span><span class="p">)</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;10000000001010001100000000000100000000000010000011000000101010000000000000011100000001000110010000000000000000010000000000010000&quot;</span>
<span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="nv">n</span><span class="p">))))))</span>
<span class="c1">; &quot;Elapsed time: 34176.316 msecs&quot;</span>
<span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="nv">n</span><span class="p">))))</span> <span class="nv">=&gt;</span> <span class="nv">n</span>
</pre></div>
</div><div><p>OK, everything's looking good. We could try using a smaller encoding and see if it still works.</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">encoder</span> <span class="p">(</span><span class="nf">r/random-sdr-encoder-1</span> <span class="ss">:diameter</span> <span class="mf">1.0</span> <span class="ss">:bits</span> <span class="mi">64</span> <span class="ss">:on</span> <span class="mi">21</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">buckets</span> <span class="p">(</span><span class="ss">:buckets</span> <span class="nv">encoder</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring!</span> <span class="nv">encoder</span><span class="p">))</span>

<span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">binomial</span> <span class="mi">64</span> <span class="mi">21</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="s">&quot;41107996877935680&quot;</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">0</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="s">&quot;1111111111111111111110000000000000000000000000000000000000000000&quot;</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="s">&quot;1111011111111111111110000000000000000010000000000000000000000000&quot;</span>
</pre></div>
</div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">n</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="s">&quot;1010100100000010010000100001000000001000000110000011110001111101&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;1000100100000010010000100001000000001000001110000011110001111101&quot;</span>
<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="nv">n</span><span class="p">)))))</span>
<span class="c1">; &quot;Elapsed time: 406.187 msecs&quot;</span>
<span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="nv">n</span><span class="p">))))</span> <span class="nv">=&gt;</span> <span class="nv">n</span>
<span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">map </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="nb">range </span><span class="mi">20000</span><span class="p">))))</span> <span class="nv">=&gt;</span> <span class="mi">20000</span>
</pre></div>
</div><div><a name="encoding-is-dependent-on-order-of-data"></a><h3><i>1.2.4 &nbsp;&nbsp; Encoding is dependent on order of data</i></h3></div><div><p>Observe the following</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring!</span> <span class="p">(</span><span class="nf">r/random-sdr-encoder-1</span> <span class="ss">:diameter</span> <span class="mf">1.0</span> <span class="ss">:bits</span> <span class="mi">12</span> <span class="ss">:on</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;111100000000&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;111000000001&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;101001000001&quot;</span> <span class="c1">;; first encoding of 2</span>
<span class="c1">;; reset</span>
<span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring!</span> <span class="p">(</span><span class="nf">r/random-sdr-encoder-1</span> <span class="ss">:diameter</span> <span class="mf">1.0</span> <span class="ss">:bits</span> <span class="mi">12</span> <span class="ss">:on</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">=&gt;</span>  <span class="s">&quot;111100000000&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span>  <span class="s">&quot;111000000001&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">-1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;110101000000&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">=&gt;</span>  <span class="s">&quot;101010000001&quot;</span> <span class="c1">;; a different encoding of 2</span>
</pre></div>
</div><div><p>The encoding of <code>2</code> thus depends on the sequence of buckets already set up when <code>2</code> is presented. The only way to avoid this is to always build the buckets in the same order, regardless of what data is presented:</p></div><div><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring!</span> <span class="p">(</span><span class="nf">r/random-sdr-encoder-1</span> <span class="ss">:diameter</span> <span class="mf">1.0</span> <span class="ss">:bits</span> <span class="mi">12</span> <span class="ss">:on</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">to-bitstring-pre</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">precalculate</span> <span class="nv">x</span> <span class="nv">to-bitstring</span><span class="p">))</span>

<span class="p">(</span><span class="nf">to-bitstring-pre</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;001000110100&quot;</span> <span class="c1">;; causes (-10,10) to be encoded in advance</span>
<span class="p">(</span><span class="nf">to-bitstring-pre</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;100000110100&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring-pre</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;100001110000&quot;</span> <span class="c1">;; first encoding of 2</span>
<span class="c1">;; reset</span>
<span class="p">(</span><span class="k">def </span><span class="nv">to-bitstring</span> <span class="p">(</span><span class="ss">:encode-to-bitstring!</span> <span class="p">(</span><span class="nf">r/random-sdr-encoder-1</span> <span class="ss">:diameter</span> <span class="mf">1.0</span> <span class="ss">:bits</span> <span class="mi">12</span> <span class="ss">:on</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">to-bitstring-pre</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">precalculate</span> <span class="nv">x</span> <span class="nv">to-bitstring</span><span class="p">))</span>
<span class="p">(</span><span class="nf">to-bitstring-pre</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">=&gt;</span>  <span class="s">&quot;001000110100&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring-pre</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span>  <span class="s">&quot;100000110100&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring-pre</span> <span class="mi">-1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="s">&quot;001010110000&quot;</span>
<span class="p">(</span><span class="nf">to-bitstring-pre</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">=&gt;</span>  <span class="s">&quot;100001110000&quot;</span> <span class="c1">;; the same encoding of 2</span>
</pre></div>
</div><div><a name="conclusions-and-further-improvements"></a><h3>1.3 &nbsp;&nbsp; Conclusions and Further Improvements</h3></div><div><p>It appears from the above tests that indeed the RDSE may be a significant improvement on the current scalar encoder. It comes a lot closer to exploiting the capacity of SDRs in the CLA.</p><p>We should investigate how we should measure the effectiveness and efficiency of our choice of encoders and encodings. While the RDSE looks promising, how can we be sure? Perhaps the swarming algorithms would be able to help us here.</p><p>This implementation, as a first draft, seems to be reasonably performant. There may be come tweaks which will speed it up a good bit (such as removing all the searching code in <code>new-sdr</code> and keeping a running cache of nearby SDRs).</p><p>Anyone interested in implementing this in C++ and Python, please do so and let us know how you get on.</p></div><div></div></section></body><script type="text/javascript">var metas = document.getElementsByTagName('meta');
var i;
if (navigator.userAgent.match(/iPhone/i)) {
  for (i=0; i<metas.length; i++) {
    if (metas[i].name == "viewport") {
      metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
    }
  }
  document.addEventListener("gesturestart", gestureStart, false);
}
function gestureStart() {
  for (i=0; i<metas.length; i++) {
    if (metas[i].name == "viewport") {
      metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";
    }
  }
}</script><script>var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-44409012-2']);
        _gaq.push(['_trackPageview']);

        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();</script></html>